# -*- coding: utf-8 -*-
"""T_{n-n}-Calc.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HiQr3N4JCPUoYe3CZ_9k_VQnFDWlbThx
"""

#import matplotlib.pyplot as plt
import numpy as np
import sympy as sp
from sympy import *

'''
def plot_diagram(diagram, title):
    fig, ax = plt.subplots()

    for line in diagram.line_list:
        x_values = [line.vs[0], line.ve[0]]
        y_values = [line.vs[1], line.ve[1]]

        # Plot line
        ax.plot(x_values, y_values, 'k-', label=line.name)

        # Optionally, mark endpoints
        ax.plot(x_values, y_values, 'ro', markersize=2)

    ax.set_aspect('equal', adjustable='box')
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_title(title)


    plt.show()
'''

def tau(a):
    b = []
    for i in range(len(a)):
        b.append(a[i])
        for j in range(i):
            if a[j] < a[i]:
                b[i] = b[i] - 2
    return b

q = sp.Symbol("q")
def quantum(n):
    return sp.cancel((q**n - q**(-n)) / (q - q**(-1)))

qarray = [quantum(n) for n in range(20)]

def quantify(a):
    expr = 1
    for i in a:
        expr = expr*qarray[i]
    return expr

def qfact(n):
    result = 1
    i = 1
    while i <= n:
        result *= quantum(i)
        i = i + 1
    return result

x = sp.Symbol("x")
y = sp.Symbol("y")
z = sp.Symbol("z")
c = quantum(2)

class Line:

  def __init__(self, vs, ve, name):
    self.vs = np.array(vs)
    self.ve = np.array(ve)
    self.name = name # for debugging

  def getOther(self, coord):
    return self.vs if self.vs == coord else self.ve == coord

  def __str__(self):
    return f"draw(({self.vs[0]}, {self.vs[1]}) -- ({self.ve[0]}, {self.ve[1]})); // {self.name}" + "\n"


class Diagram:

  def __init__(self, line_list, coeff=1):
    self.line_list = line_list
    self.coeff = coeff

  def __str__(self):
    ret = ""
    for line in self.line_list:
      ret = ret + line.__str__()
    return ret

  def line_reset(self, new_list):
    self.line_list = new_list

  def evaluate(self, punctures):
    polygons = []
    expr = self.coeff
    remaining = list(self.line_list)  # work on a copy

    def same_point(a, b, tol=1e-9):
        return np.allclose(a, b, rtol=0, atol=tol)

    i = 0
    remaining_lines = list(self.line_list)
    while i < len(self.line_list):
      polygon = [] # create a polygon

      polygon.append(remaining_lines.pop()) # by removing the 1st line in self.line_list (increment index)
      i = i + 1

      while not same_point(polygon[-1].ve, polygon[0].vs): # as long as the last line does not coincide with the initial one
        for line in remaining_lines: # look thru each line in remaining_lines
          if same_point(line.vs, polygon[-1].ve): # until you find the (only) other line who coincides with the given line
            polygon.append(line) # add this line to the polygon
            remaining_lines.remove(line) # and remove it from remaining_lines
            i = i + 1
            break
          elif same_point(line.ve, polygon[-1].ve): # if the orientation of the other line is flipped
            vs = line.vs # then alter it
            line.vs = line.ve
            line.ve = vs
            polygon.append(line)
            remaining_lines.remove(line) # and remove it from self.line_list
            i = i + 1
            break

      polygons.append(polygon)
      ## print("\n***POLYGON")
      #for line in polygon:
      #  # print(line)
      ## print("***\n")


    # now compute the winding numbers of each polygon via ray casting
    for polygon in polygons:
      w = [0, 0]
      for i in range(2): # a puncture is a (x, y)
        puncture = punctures[i]
        p = np.array([puncture[0], puncture[1]])
        for line in polygon:
          if line.ve[1] != line.vs[1] and line.vs[0] + (line.ve[0] - line.vs[0]) * (p[1] - line.vs[1]) / (line.ve[1] - line.vs[1]) > p[0]:
            if line.vs[1] < p[1] and p[1] < line.ve[1]:
              w[i] = w[i] + 1
            elif line.vs[1] > p[1] and p[1] > line.ve[1]:
              w[i] = w[i] - 1
            elif (line.vs[1] < p[1] and p[1] == line.ve[1]) or (line.vs[1] == p[1] and p[1] < line.ve[1]):
              w[i] = w[i] + 0.5
            elif (line.vs[1] > p[1] and p[1] == line.ve[1]) or (line.vs[1] == p[1] and p[1] > line.ve[1]):
              w[i] = w[i] - 0.5
      if w[0] != 0 and w[1] != 0:
        expr = expr * z
      elif w[0] == 0 and w[1] != 0:
        expr = expr * y
      elif w[0] != 0 and w[1] == 0:
        expr = expr * x
      else:
        expr = -c * expr

    return sp.simplify(expr)

import json
import numpy as np
import ast

#HARDCODE LAND ------------------ÃŸ---
file_path1 = '/Users/parthwokhlu/Documents/Jones-Wenzl Algo/T(3,8,5).json'
file_path2 = '/Users/parthwokhlu/Documents/Jones-Wenzl Algo/lines8.txt'
file_path3 = '/Users/parthwokhlu/Documents/Jones-Wenzl Algo/evaluations8new.txt'
qfact = qfact(8) 
#HARDCODE LAND ---------------------

with open(file_path1, 'r') as f:
    layout = json.load(f)
print("1-----", flush= True)
connections=[]
i=0
with open(file_path2, 'r') as f:
  for line in f:
    string_part, rest = line.split("),", 1)
    string_part += ")"  # put back the removed ")"

    tuple_list = ast.literal_eval("[" + rest + "]")

    result = [string_part] + tuple_list
    connections.append(result)
    i+=1

result_list = []
punctures = [(layout["punctures"][i]["coor"][0], layout['punctures'][i]["coor"][1]) for i in range(2)]
print(punctures, flush =True)
curves =[]

for line_data in layout["segments"]:
  curves.append(Line((line_data["p0"][0],line_data["p0"][1]), (line_data['p1'][0],line_data['p1'][1]), line_data['id']))

for list_of_pairs in connections:
  pairs = list_of_pairs[1:]
  new = []

  for pair in pairs:
    A = (layout["special_points"][pair[0]-1]["coor"][0], layout["special_points"][pair[0]-1]["coor"][1])
    B = (layout["special_points"][pair[1]-1]["coor"][0], layout["special_points"][pair[1]-1]["coor"][1])
    new.append(Line(A, B, str(pair[0]) + "-" + str(pair[1])))

  line_list = curves + new
  d = Diagram(line_list)
  result_list.append([d.evaluate(punctures), None])
print("2-----", flush= True)
j = 0
file = open(file_path3, 'r')

for line in file:
    arr = line.split(";")
    if len(arr) < 3:
        continue
    arr = arr[1:-1]
    expr = 0
    for seq in arr:
        int_seq = [int(item) for item in seq.split(",")]
        expr += quantify(int_seq)
    result_list[j][1] = expr
    j += 1

batch_size = 100
super_batch_size = 4   # number of 100-batches to combine

num_batches = (len(result_list) + batch_size - 1) // batch_size
batch_sums = [0] * num_batches

for i in range(num_batches):
    print(f"batch{i}", flush= True)
    start = i * batch_size
    end = start + batch_size
    batch = result_list[start:end]

    bsum = 0
    for arr in batch:
        bsum += arr[0] * arr[1]
    batch_sums[i] = bsum

num_super = (len(batch_sums) + super_batch_size - 1) // super_batch_size
super_sums = [0] * num_super

for j in range(num_super):
    print(f"super batch{j}", flush = True)
    start = j * super_batch_size
    end = start + super_batch_size
    super_batch = batch_sums[start:end]

    ssum = 0
    for val in super_batch:
        ssum += val
    super_sums[j] = ssum

result = 0
for val in super_sums:
    result += val

result = result / qfact 
print(result, flush= True)

n, d = sp.fraction(sp.cancel(result))

print(n, flush= True)
print(d, flush= True)
print("4------")

#HARDCODE
nnew = n.subs(q, exp(2*pi*I/5)).rewrite(cos)
dnew = d.subs(q, exp(2*pi*I/5)).rewrite(cos)

final_num = sp.latex(nnew)
final_denom = sp.latex(dnew)
print(final_num, flush= True)
print(final_denom, flush= True)

with open("numerator.txt", "w", encoding="utf-8") as f:
    f.write(final_num)

with open("denominator.txt", "w", encoding="utf-8") as f:
    f.write(final_denom)